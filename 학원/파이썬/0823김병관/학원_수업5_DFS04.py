# 음료수 얼려 먹기
# N, M을 공백으로 구분하여 입력받기

n,m = map(int, input().split())

# 2차원 리스트의 맵 정보 입력받기
graph = []

for i in range(n):

    graph.append(list(map(int,input())))

# DFS로 특정한 노드를 방문한 뒤에 연결된 모든 노드들도 방문

def dfs(x,y):

    # 주어진 범위를 벗어나는 경우에는 즉시 종료

    if x <= -1 or x >= n or y <= -1 or y >= m:

        return False
    # 현재 노드를 아직 방문하지 않았다면

    if graph[x][y] == 0:
        # 해당 노드 방문 처리

        graph[x][y] = 1
        # 상,하,좌,우의 위치도 모두 재귀적으로 호출

        dfs(x-1,y)

        dfs(x,y-1)

        dfs(x+1,y)

        dfs(x,y+1)

        return True

    return False

# 매트릭스에서 0의 값이 발견되기만 한다면, 그 0에서 재귀적인 함수가 있더라도, 그 실행의 끝에는 항상 위의 if문의 True가 도출된다는 것이다. 즉, 0이면 무조건 True가 된다. 마찬가지로, 재귀에 의해 실행되는 dfs에 의한 결과도 4갈래의 dfs가 실행된다 할지라도, 0이면 무조건 그 기나긴 최종적인 결과는 항상 True가 된다는 것이다.

# 따라서 결과적으로, 0으로 표현된 원소의 좌표의 dfs 값은 결과적으로 항상 True로 도출된다는 것이므로, 아래의 if문과 같은 코드를 설정할 수 있는 것이다.

#



# 모든 노드(위치)에 대하여 음료수 채우기

result = 0

for i in range(n):

    for j in range(m):

        # 현재 위치에서 DFS 수행

        if dfs(i,j) == True:

            result = result + 1

print(result) # 정답 출력

# 함수에서 return은 오직 한번만 발생할 수 있다.

# dfs(0,0)에 의해서 함수가 시작되어 4개의 dfs 함수가 다시 재귀적으로 계속하여 호출되더라도 상하좌우 모든 방향에서 1로 둘러싸여서 더이상 어느방향으로도 진행할 수가 없는 순간에 4개의 dfs가 모두 False로 결정되게 되어 최초로 True가 return 되게 된다.

# return은 본질적으로 오직 단 한번만 발생되는 것이므로, 재귀함수에 의해 이전에 실행을 묵혀뒀던 모든 동작을 무시해버리게 된다. 즉, 이경우 return은 break와 비슷한 느낌으로 작용하여, dfs(0,4)에서 최초로 return True가 발생하게 되므로, dfs(i,j)에 대해서 True 값으로 결정되는 것은 dfs(0,0) ~ dfs(0,4)까지 dfs(0,4)가 유일한 것이다.

# 왜냐하면 dfs(0,0),dfs(0,1),dfs(0,2)는 각각 4개의 dfs 문장을 실행하는 과정에서 모든 4개의 dfs를 False로 끝맺지 않아서 4개의 dfs 문장 뒤에 있는 return True 문장이 실행조차 되지 않고 묵혀져 있는 상태이기 때문이다.

# 즉, 4개의 문장을 모두 실행하여 그 뒤에 있는 return을 실행하여 함수동작을 종결시킬 수 있는 것은 이경우 오직 dfs(0,4)뿐이 존재하지 않는다.

# 따라서, 될 수있으면 return은 함부러 쓰지 않는다

# return은 항상 자신을 부른 함수로 돌아간다. 돌아가면 , 돌아가는 순간 그 함수가 끝나고, 그 이전에 동작을 묵혀있던 함수도 끝나는 것이다.

## update
## return이 발생하면, return이 발생되게 한 함수로 return 값이 돌려지고, 그 함수가 종료된다. 즉, 함수가 종결되는 것이다. 그러나 이때, 앞서서 존재하여 동작이 묵혀져있던 재귀함수까지 모두 한꺼번에 종결되는 것은 아니다. 단지, return이 발생되게한 그 끝 함수만이 끝나는 것이다.

## 컴퓨터에선 묵혀져있는 개념이란게 없다. 즉, 동작을 요청했으면 반드시 끝나야하는 것이다. 그래서 만약 (0,0)에서 시작하여 (0,6)에서 벽이 존재하여 끝나는 경우에 dfs(0,6) 은 return True가 최초로 발생되지만, return이 발생되었다고 해서 그 이전에 존재하고, 현재 동작이 묵혀져 있던 dfs(0,1) ~ dfs(0,5)가 묵혀진 상태로 함수가 종결되는 것이 아니라,
# dfs(0,6)에 의해 발생된 return이 dfs(0,6)을 호출한 dfs(0,5)에게 돌려지고, dfs(0,5)가 종료되지 않고, 즉, return이 발생되지 않고 묵혀져 있던 이유는 dfs(0,5)에 의해 dfs(0,6)이 실행되고 있는 중이기 때문이었는데, dfs(0,6)에서 return이 발생하였으므로, dfs(0,5)에서도 return이 발생하게 된다.
# 마찬가지로 dfs(0,5)에서 return이 발생하게 되면서, dfs(0,4)가 종료되지 않고 묵혀져 있던 이유가 dfs(0,4)에 의해 dfs(0,5)가 실행중이기 때문이었는ㄴ데, dfs(0,5)에 return이 발생하여 종결되었으므로, dfs(0,5)를 호출한 dfs(0,4)에게 return값이 돌려지면서, dfs(0,4)또한 return이 발생하게 된다.
# 이러한 연쇄적인 과정이 dfs(0,0)에게 까지 발생하여 결과적으로 모든 dfs(0,1) ~ dfs(0,5)가 존재할 수 있게한 dfs(0,0)에서도 return True 값이 발생하게 되어 최초로 내가 컴퓨터에서 질문했던 dfs(0,0)은 무엇이냐에 대한 답으로 True를 얻게 되는 것이다.
# 따라서, 아이스크림의 끝 요소의 dfs 값이 True여서 함수가 종결되는 것이 아니라, 최초의 요소의 dfs 값이 True가 되면서 함수가 종결되는 것이다.

# 컴퓨터에선 묵혀두는 개념이란 존재하지 않는다. 반드시 컴퓨터에게 질문을 하면, 그 최초의 질문에 대한 하나의 결과값을 돌려준다. 즉, 최초의 질문에 의해 호출된 모든 동작은 반드시 종결되어야 한다.

# 만약 "상자 1에 무엇이 들어있냐?"고 컴퓨터에게 물어봤을때, 상자 1안에 상자 1보다 작은 상자2가 들어있고, 상자 2안에 상자3이 들어있고 계속해서 나아가다 상자 6까지 들어있는 경우, 상자 6을 열어보니 콩이 하나가 들어있을 때, 최종적으로 컴퓨터는 "상자 6에 콩이 들어있습니다."라고 답하지 않고, "상자 1에 콩이 들어있습니다."라는 답을 준다.
# 즉, 컴퓨터는 최초의 질문에 대한 답만을 결과값으로 돌려주는 존재인 것이다. 그 중간에 이뤄지는 동작에 대한 결과는 단지 과정일 뿐이다. 그리고, 그 중간과정에서 발생한 동작은 반드시 종결되어야만 한다. 발생한 동작을 종결시키지 않는 경우는 컴퓨터에서 존재하지 않는다.
