# 음료수 얼려 먹기
# N, M을 공백으로 구분하여 입력받기
n,m = map(int, input().split())

# 2차원 리스트의 맵 정보 입력받기
graph = []
for i in range(n):
    graph.append(list(map(int,input())))

# DFS로 특정한 노드를 방문한 뒤에 연결된 모든 노드들도 방문
def dfs(x,y):
    # 주어진 범위를 벗어나는 경우에는 즉시 종료
    if x <= -1 or x >= n or y <= -1 or y >= m:
        return False
    # 현재 노드를 아직 방문하지 않았다면
    if graph[x][y] == 0:
        # 해당 노드 방문 처리
        graph[x][y] = 1
        # 상,하,좌,우의 위치도 모두 재귀적으로 호출
        dfs(x-1,y)
        dfs(x,y-1)
        dfs(x+1,y)
        dfs(x,y+1)
        return True

    return False
# 매트릭스에서 0의 값이 발견되기만 한다면, 그 0에서 재귀적인 함수가 있더라도, 그 실행의 끝에는 항상 위의 if문의 True가 도출된다는 것이다. 즉, 0이면 무조건 True가 된다. 마찬가지로, 재귀에 의해 실행되는 dfs에 의한 결과도 4갈래의 dfs가 실행된다 할지라도, 0이면 무조건 그 기나긴 최종적인 결과는 항상 True가 된다는 것이다.

# 따라서 결과적으로, 0으로 표현된 원소의 좌표의 dfs 값은 결과적으로 항상 True로 도출된다는 것이므로, 아래의 if문과 같은 코드를 설정할 수 있는 것이다.




# 모든 노드(위치)에 대하여 음료수 채우기
result = 0
for i in range(n):
    for j in range(m):
        # 현재 위치에서 DFS 수행
        if dfs(i,j) == True:
            result = result + 1

print(result) # 정답 출력

# 함수에서 return은 오직 한번만 발생할 수 있다.
# dfs(0,0)에 의해서 함수가 시작되어 4개의 dfs 함수가 다시 재귀적으로 계속하여 호출되더라도 상하좌우 모든 방향에서 1로 둘러싸여서 더이상 어느방향으로도 진행할 수가 없는 순간에 4개의 dfs가 모두 False로 결정되게 되어 최초로 True가 return 되게 된다.
# return은 본질적으로 오직 단 한번만 발생되는 것이므로, 재귀함수에 의해 이전에 실행을 묵혀뒀던 모든 동작을 무시해버리게 된다. 즉, 이경우 return은 break와 비슷한 느낌으로 작용하여, dfs(0,4)에서 최초로 return True가 발생하게 되므로, dfs(i,j)에 대해서 True 값으로 결정되는 것은 dfs(0,0) ~ dfs(0,4)까지 dfs(0,4)가 유일한 것이다.
# 왜냐하면 dfs(0,0),dfs(0,1),dfs(0,2)는 각각 4개의 dfs 문장을 실행하는 과정에서 모든 4개의 dfs를 False로 끝맺지 않아서 4개의 dfs 문장 뒤에 있는 return True 문장이 실행조차 되지 않고 묵혀져 있는 상태이기 때문이다.
# 즉, 4개의 문장을 모두 실행하여 그 뒤에 있는 return을 실행하여 함수동작을 종결시킬 수 있는 것은 이경우 오직 dfs(0,4)뿐이 존재하지 않는다.

# 따라서, 될 수있으면 return은 함부러 쓰지 않는다
# return은 항상 자신을 부른 함수로 돌아간다. 돌아가면 , 돌아가는 순간 그 함수가 끝나고, 그 이전에 동작을 묵혀있던 함수도 끝나는 것이다.