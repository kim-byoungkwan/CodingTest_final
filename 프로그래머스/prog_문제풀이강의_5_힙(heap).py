###.1 힙(Heaps)

# 힙을 이용하면 최대/최소의 원소를 빠르게 상수시간의 시간복잡도로 찾을 수 있다.

# 힙 자료구조의 대표적인 연산은 힙을 구성하는 heapify와 임의의 원소를 주어진 힙 자료구조 안에 힘의 본질을 훼손하지 않고 삽입하는 insert연산, 최대힙에서는 최대값 노드를 효율적인 시간 복잡도로 삭제하고, 최소힙에서는 최소값 노드를 효율적인 시간 복잡도로 삭제할 수 있는 remove 연산 등이 존재한다. 마찬가지로 힙의 remove연산을 수행하고 난 뒤에도 힙의 본질은 훼손되지 않는다.

# 힙의 insert 연산과 remove 연산의 시간 복잡도는 O(logN) 으로 결정된다. 그리고 heapify 연산의 시간 복잡도는 O(nlogn)의 시간복잡도로 결정된다.

# 힙은 완전이진트리이기 때문에 본질적으로 배열을 이용해서 구현가능하다.

import heapq

# heap 자료구조와 메소드를 사용할 수 있는 환경을 마련해주는 heapq 라이브러리를 불러온다.

heapq.heapify(L)

# heapq 라이브러리의 heapify 메소드는 인자로 할당된 리스트 L의 원소를 이용하여 최소 힙을 구현해주는 메소드이다. 리스트 L의 원소가 어떤 순서로 리스트 L에 존재하든지 상관없이 최소힙을 구현해주게된다. 이때 생성된 최소 힙은 리스트 L안에 여전히 존재하고 있다. 왜냐하면 최소 힙은 본질적으로 완전 이진 트리이기 때문에 본질적으로 리스트로 표현할 수 있기 때문이다. 즉, 이때 생성된 최소힙의 노드는 리스트 L의 인덱스를 통하여 접근할 수 있는 것이다.

m = heapq.heappop(L)

# 최소힙의 형태인 리스트 L의 최소값이 할당된 노드인 뿌리노드를 제거하여 m에 할당하고, 최소값 뿌리노드가 제거된 뒤, 또 다시 최소힙의 형태로 재정렬 되어 뿌리노드에 또 다른 최소값이 이어져 할당된 상태가 된다.

# 이때, 시간 복잡도는 최소힙 리스트 L의 뿌리노드를 제거하는 동작은 상수 시간 복잡도를 가지지만, 뿌리노드를 제거하고 나머지 모든 노드를 다시 재정렬하여 최소힙의 구조로 만드는 동작은 o(nlogn)의 시간 복잡도를 갖게된다.

heapq.heappush(L,x)

# 최소힙을 표현하는 리스트 L에 원소 x를 최소힙 구조의 본질을 해치지 않으면서 삽입하는 동작이다.


def solution(scoville,K):

    answer = 0

    heapq.heapify(scoville)

# 문제에서 주어진 scoville 리스트를 최소힙의 형태로 변환한다.

    while True:

        min1 = heapq.heappop(scoville)

# scoville 리스트를 최소힙으로 변환하고, 변환된 최소힙의 최소값을 갖고 있는 뿌리노드를 출력하여 min1에 할당한다.

        if min1 >= K:

            break

        elif len(scoville) == 0:

            answer = -1

            break

# 최소힙인 scoville의 최소값을 포함한 노드인 뿌리노드를 제거하고 났더니 최소힙에 노드가 한개도 존재하지 않는 경우를 표현하는 것이다.

        min2 = heapq.heappop(scoville)

# 최초의 최소힙 scoville의 뿌리노드를 제거하고 난 뒤의 두번째 최소값을 표현하는 두번째 뿌리노드를 min2가 표현하는 것이다.

        new_scoville = min1 + min2*2

        heapq.heappush(scoville,new_scoville)

        answer += 1

    return answer


## 위의 while 문의 시간 복잡도는 heapq의 메소드인 heappop와 heappush가 모두 O(logn)의 시간복잡도를 가지는데 이러한 동작이 n개의 원소에 대해서 while문을 통해 반복되므로 최종적인 시간복잡도는 O(nlogn)으로 결정되게된다.















