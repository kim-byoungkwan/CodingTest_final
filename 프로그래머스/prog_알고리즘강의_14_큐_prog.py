###.1 큐(Queues)

# "큐" 라는 자료구조는 자료를 보관할 수 있는 선형구조를 의미한다.

# 단, 큐 자료구조에 데이터를 넣을 때에는 한 쪽 끝에서 밀어 넣어야 하고, 데이터를 꺼낼 때에는 데이터를 넣었던 방향과 반대방향에서 데이터를 꺼내야 하는 자료구조이다.

# 이때, 한쪽끝에서 데이터를 넣는 연산을 인큐(enqueue) 연산이라고 하고, 반대쪽에서 데이터를 꺼내는 연산은 디큐(dequeue) 연산이라고 한다.

# 큐라는 자료구조는 이러한 원칙 때문에 먼저 들어간 데이터가 먼저 나오는 선입선출(FIFO, First in First Out)의 방식으로 데이터를 입출력하게 된다. 즉, 데이터가 들어간 순서와 데이터가 나오는 순서가 동일한 순서인 것이다. 나중에 들어간 것이 가장 먼저 나오는 스택과는 다른 성격을 갖는다.





###.2 큐의 구현


##.1 큐를 배열(array)을 이용하여 구현하는 방법은 리스트와 메소드를 이용하면된다.

class ArrayQueue:

    def __init__(self):

        self.data = []

    def size(self):

        return len(self.data)

    def isEmpty(self):

        return self.size() == 0

    def enqueue(self,item):

        self.data.append(item)

    def dequeue(self):

        return self.data.pop(0)

# 큐의 0번 인덱스에 있는 원소를 꺼내서 return 하고, 0번 인덱스에 있던 원소를 빼고 남아있던 원소들을 다시 큐의 0번 인덱스부터 이어서 배열시키게 된다. 즉, pop 메소드의 인자값을 0으로 지정하는 순간 먼저 들어간 것이 가장 먼저 나오는 큐의 본질적인 동작이 구현되게 되는 것이다.

# dequeue 메소드는 큐의 길이가 길어지면 길어질수록 복잡도가 증가하게 되는 O(n)의 시간복잡도를 갖게 된다. 즉, dequeue 메소드를 실행하여 가장 맨 앞에 있는 원소가 출력되고 나면 큐에 존재하는 나머지 모든 원소들이 한칸씩 0번째 인덱스의 원소를 메우기 위해 옮겨져야 되므로, 큐의 길이가 길면 길수록 이 나머지 원소들의 한칸씩 이동하는 이동횟수가 비례하여 증가하게 되므로 dequeue의 동작의 시간 복잡도는 O(n)으로 표현되게 되는 것이다.

# dequeue 메소드를 제외한 나머지 큐의 모든 메소드들의 시간 복잡도는 O(1)로 표현되게 된다.


    def peek(self):

        return self.data[0]

# 큐에 가장 먼저 들어간 원소가 무엇인지 단지 보여주기만 하는 메소드이다.











