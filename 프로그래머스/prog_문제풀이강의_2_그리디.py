###.1 그리디

# 탐욕법이란 알고리즘의 각 단계에서 그 순간에 자기 자신의 주변만 보는 지역적 관점에서 최적이라고 생각되는 것을 선택하는 알고리즘이다. 단, 현재의 최적의 선택이 마지막 해답의 최적성을 해치지 않을 때에만 탐욕법이 적용가능하다.

# 탐욕법을 적용하는 것을 고려할 때, 배열을 정렬하는 과정 또한 생각해줘야 한다.

# 코드의 구성에서 시간복잡도가 O(n) 경우와 O(nlogn)인 경우가 나뉘어질 때, n의 크기를 고려하여 유리한 방향으로 코드를 작성해야한다.

def solution(n,lost,reserve):

    u = [1]*(n+2)

# 길이가 n+2 이고 초깃값이 1인 배열을 생성한다. 1번 인덱스의값이 1번째 학생을 의미하는 원소를 가리키기 위해 0번째 인덱스와 맨마지막 인덱스보다 하나 더큰 인덱스에도 원소를 할당해주는 개념이다. 마지막 인덱스의 하나 더큰 인덱스 원소를 생성해주는 것은 원소의 앞/뒤 연산을 첫번째부터 마지막번째 인덱스의 원소에 동일한 상황에서 고려해주는 환경을 만들기 위함이다.

    for i in reserve:

        u[i] = u[i] + 1

    for j in lost:

        u[j] = u[j] - 1

    for k in range(1,n+1):

        if u[k-1] == 0 and u[k] == 2:

            u[k-1:k+1] = 1,1

        elif u[k+1] == 0 and u[k] == 2:

            u[k:k+2] = 1,1

# for문에 if/elif 가 중첩되어있는 위의 코드는 정확히 n회 반복하므로 이 코드의 시간복잡도 또한 O(n)으로 표현된다.

    final = [m for m in range(1,n+1) if u[m] > 0]

    return len(final)


###.2

# 파이썬에서 집합(set) 자료구조는 본질적으로 해시로 이루어져있기 때문에 집합자료구조의 원소를 상수시간으로 접근할 수 있다.

# 집합 자료구조는 어떠한 원소가 속해 있는지 아닌지만을 판단할 때 유용한 자료구조이다.

def solution(n,lost,reserve):

    s = set(lost) & set(reserve)

# 두 배열 lost와 reserve를 집합의 형태로 만들어 두 집합의 교집합을 & 기호를 이용하여 생성하여 그 교집합을 s라는 변수에 할당하는 것이다. 즉, s는 여분을 갖고 있으면서 동시에 도난당한 학생을 표현하는 집합이다.

    l = set(lost) - s

# l은 차집합으로 형성된 집합인데, 이 경우 여분을 갖고 있지 않은 도난당한 학생들을 표현하는 집합이다. 즉, 체육복을 제공받아야만 체육수업에 참여할 수 있는 학생들을 표현하는 집합이다. 다시말하면, 현재 체육수업에 참여할 수 없는 상태인 학생들의 집합인 것이다.

    r = set(reserve) - s

# r 차집합은 여분을 갖고 있으면서 도난 당하지 않은 학생을 표현하는 집합이다. 즉, 도난 당한 학생에게 여분의 체육복을 제공해줄 수 있는 사람들의 집합을 의미한다.

    for x in sorted(r):

        if x-1 in l:

            l.remove(x-1)

        elif x+1 in l:

            l.remove(x+1)

    return n - len(l)

# sorted 연산에 의해 이 코드의 시간복잡도는 O(nlogn) 으로 결정된다. 그러나, reserve의 숫자가 n 보다 월등히 작은 경우에 시간복잡도에서 훨씬 첫번째 코드보다 효율적인 코드이다.

    





































    return

