###.1 동적계획법(Dynamic Programming)

# 문제의 답을 도출하기 위해 탐색해야하는 범위를 솔루션 스페이스(solution space)라고 하는데, 이러한 솔루션 스페이스를 한번에 전체를 탐색하고자 하는 것이 아니라, 진전하면서 동적으로 탐색하는 방식을 동적계획법이라고 한다.

# 주어진 최적화 문제를 재귀적인 방식으로 보다 작은 부분의 문제로 나누어, 그 나누어진 부분의 문제를 풀고, 이 때 발생된 부분의 해를 조합하여 전체 최적화 문제의 해답을 도출하는 방식을 동적계획법이라고 한다.

# 알고리즘이 탐색해야할 범위를 시작하면서 미리 규정하는 것이 알고리즘이 진행함에 따라서 동적으로 결정함으로써 탐색 범위를 한정할 수 있는 방법을 동적계획법이라고 한다.

# 즉, 어떠한 솔루션의 범위가 아주 큰 상황일 때, 발생할 수 있는 모든 조합을 모두 고려하고자 한다면 매우 큰 범위를 탐색해야 하는 어려움이 발생하지만, 솔루션의 범위를 부분부분으로 나누어서 해를 구하고, 그 다음 부분 단계의 해를 구하는 방식으로 점진적으로 나아가며 솔루션을 구하는 방식을 동적계획법이라고 하는 것이다.


def solution(N,number):

# 숫자 N만을 사용하여 number 숫자를 표현할 때의 N을 사용하는 최소 횟수를 출력하는 함수이다.

    s = [set() for x in range(8)]

# s라는 리스트의 8개의 원소에 초기화된 상태의 집합(set)을 할당한다.

    for i,x in enumerate(s, start=1):

# enumerate 메소드의 start 인자에 아무것도 할당하지 않으면, s 리스트의 원소에 0부터의 인덱스를 대응시켜 i에 할당하지만, start 인자에 1 을 할당하면, s 리스트의 원소에 1부터의 인덱스를 대응시켜 i에 할당하게된다.즉, 이경우엔 s 리스트의 원소는 초기화된 상태의 집합 8개 이므로, x에는 초기화된 상태의 집합이 할당되고, i에는 인덱스 값 1부터 8까지 할당되게된다.

        x.add(int(str(N)*i))

# 현재 x는 초기화된 상태의 집합(set)을 표현하므로, 집합에 원소를 추기하기 위한 메소드인 add를 사용하여 초기화된 상태의 집합에 숫자 N을 i가 표현하는 숫자 1,2,3,4,5,6,7,8을 곱한 값을 각각 할당한다. 즉, 결과적으로 모든 초기화된 상태의 집합에 그 집합의 인덱스 만큼 반복된 숫자N이 하나씩 할당되어 있게 된다.
# 즉, 위의 과정은 숫자 N을 가장 단순한 방법인 아무런 사칙연산을 적용하지 않고 그대로 표현한 모든 경우를 나타낸 것이다.

    for i in range(len(s)):

        for j in range(i):

# i = 0인 경우 range(0)은 아무것도 존재하지 않는 리스트 [] 를 의미하므로, 이 때엔 for문은 j에 할당될 수 있는 원소가 존재하지 않으므로, fort문이 한번도 반복되지 않고 바로 종료되게 되어 바로 바깥의 fot문의 i가 i = 0 인 경우부터 다시 for문이 시작되게 된다.

            for op1 in s[j]:

                for op2 in s[i - j -1]:

                    s[i].add(op1 + op2)
                    s[i].add(op1 - op2)
                    s[i].add(op1 * op2)

                    if op2 != 0:

                        s[i].add(op1 // op2)

# 결정적인 순간은 i=1, j=0 인 순간이다. 이때부터, 한자리 수(ex.5)인 s[0]이 op1과 op2에 모두 할당되게 되면서, 예를 들어 op1 = 5, op2 = 5 인 상태에서 사칙연산이 모두 수행되어 현재 i=1 에 의해 55 가 들어있는 s[1] 집합에 op1과 op2 의 사칙연산의 결과값이 모두 s[1] 집합에 할당되게된다.
# 그 결과 s[1]은 {55,5+5,5-5,5*5,5//5} 가 되면서 5를 2번 이용해서 생성할 수 있는 모든 값이 할당되게된다.
# 위 과정이 끝나고 i=2,j=0,1인 과정에서는 현재 555 가 할당되어 있는 s[2]에 op1=s[0],s[1] 이고, op2=s[1],s[0]이므로, 이때, 위의 과정에서 생성되어 s[1]에 할당된 5를 사칙연산을 이용하여 2번 사용해 만든 모든 값과 s[0]에 할당된 5를 사칙연산을 이용하여 1번 사용해 만든 모든 값을 앞 뒤 순서를 바꾸어 모두 계산하여 s[2]에 할당하게 되는데, 이때 s[2]는 집합 자료구조 이므로, 중복된 값은 자동으로 제거되어 유일한 값만 s[2]에 남게 된다.
# 결과적으로 s[2]에는 5를 사칙연산을 이용하여 3번 사용하여 발생될 수 있는 모든 값이 저장되게 되는 것이다. 이때, s[2]의 원소를 생성할 때, s[0]과 s[1]를 생성할 때 이미 연산을 적용하여 발생된 결과값을 그대로 사용하였으므로, s[2] 집합은 s[0]의 원소와 s[1]의 원소를 생성하는 연산은 생략한 채로 결과값만을 이용해 s[2]의 원소를 생성하였다.
# 이러한 과정이 다음의 과정에서도 계속 반복되게 되므로, 솔루션 스페이스를 분할 하여 해결하는 동적계획법을 적용한 코드라고 할 수 있다.

        if number in s[i]:

            answer = i + 1

            break

# i에 관한 for문의 한번의 시행이 끝났을 때마다 위의 if 조건문을 실행하여 가장 적은 횟수의 숫자N을 사용하여 우리가 찾고자 하는 number을 생성하였는 지를 점검한다. 이때 s[1]에는 N을 2번사용하여 생성할 수 있는 모든 숫자를 갖고 있으므로, 결과적으로 사용횟수는 i+1로 표현되게된다.

    else:

        answer = -1

# for문의 모든 i 값을 반복했음 해도 불구하고 break를 만나지 않았다는 것은 우리가 생성한 모든 집합 s[i]에서 우리가 찾고자하는 number 이라는 숫자가 존재하지 않는 다는 것이고, 이는 N을 8회 사용하여 만들 수 있는 모든 숫자속에 number이라는 숫자가 존재하지 않음을 의미하므로 if 에 대한 else의 결과 값은 answer 에 -1로 할당되게 된다.
# if/else 구문은 위와같이 간격이 다른상황에서도 적용할 수 있다.


    return answer










