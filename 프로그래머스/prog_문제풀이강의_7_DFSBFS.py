###.1 깊이 우선 탐색(DFS; Depth-First Search)

# 한 정점에서 인접한 모든(아직 방문하지 않은) 정점을 방문하되, 각 인접 정점을 기준으로 깊이 우선 탐색을 끝낸 후 다음 정점으로 진행하는 방식을 깊이 우선 탐색(DFS)방식 이라고 한다.

# 이러한 DFS 방식을 구현하기 위해서는 어느 정점에서 DFS를 진행하고 있는지를 기억해야 하므로 스택을 이용하는 것이 필요하다.

# dfs에서는 모든 정점을 방문하는 것이 목적이 아니라, 모든 간선을 거치는 것이 목적이다.

# "한붓그리기"문제는 스택을 이용하여 해결한다.

# 이 문제의 경우에는 방문하는 공항을 스택에 집어넣는 방식으로 해결한다.

###.2 너비 우선 탐색(BFS; Breadth-First search)

# 한 정점에서 인접한 모든(아직 방문하지 않은) 정점을 방문하고, 방문한 각 인접 정점을 기준으로(방문한 순서에 따라) 또 다시 너비 우선 탐색을 행한다.

# 이러한 BFS 방식을 구현하기 위해서는 어느 정점에서 BFS를 해야하는 지를 기록하고 진행해야 하기 때문에 큐를 이용하는 것이 필요하다.

def solution(tickets):

    routes = {}

    for t in tickets:

        routes[t[0]] = routes.get(t[0],[]) + [t[1]]

# routes 라는 딕셔너리에 key 값이 출발하는 공항이 할당되고, value 값에는 도착하는 공항이 리스트의 형태로 할당되어있는 딕셔너리가 생성된다.
# 그리고 위와 같은 코드로 표현한 이유는 예를들어 ICN공항에서 도착할 수 있는 공항의 종류가 AFL,SFO와 같이 2가지인 경우, tickets 리스트에 [ICN,AFL] 인 원소와 [ICN.SFO] 인 원소가 존재하므로,
# ICN이 키인 경우 value로 먼저 AFL이 대응되고, 그 뒤로 다시 [ICN.SFO] 원소를 만났을때, ICN 키에 대한 value 값으로 이미 [AFL]이 리스트의 형태로 설정되어 있으므로,
# get 메소드의 결과 [AFL] 이 출력되고 이어서 [SFO] 가 더해지므로, 결과적으로 key 값이 ICN이고, 그에 대응되는 value가 [AFL,SFO]인 딕셔너리를 생성하게 된다.

    for r in routes:

        routes[r].sort(reverse=True)

# r변수에는 딕셔너리인 routes의 key가 할당된다. 즉, routes[r]은 키 r에 대한 value를 표현하고 그 value를 알파벳 순서의 반대방향으로 정렬하는 것이다. 이때 sort 메소드를 사용하는 이유는 value는 이경우 리스트형태이기 때문이다.

# 즉, 위 코드는 routes 딕셔너리의 각각의 키에 대응 되는 모든 value들을 알파벳 역순으로 정렬하는 것이다. 위 결과 각각의 키에 대응 되는 모든 routes 딕셔너리의 value들의 순서는 알파벳 역순을 따르게 된다.

    stack = ["ICN"]

    path = []

    while len(stack) >0:

        top = stack[-1]

# 위의 top 변수에는 항상 내가 이전에 방문한 공항이 할당되게 된다.

        if top not in routes or len(routes[top]) == 0:

# 위의 or 조건중에 하나라도 만족하면 if문이 실행된다. 즉, 이 if 문이 실행되지 않고 else 문이 실행되려면, 두조건 모두가 동시에 false 여야 하므로, stack의 맨 위에 존재하는 값이 출발 공항이어야 하고, 그 출발공항의 도착지가 존재하여야 한다.
# 이러한 경우 최종 도착지 공항이 절대 될 수 없으므로, pop을 실행하여 path에 담는 연산이 실행되어선 안된다. 즉 else가 실행되어야 한다.
# top not in routes 조건은 top에 있는 공항이 무조건 도착지 공항으로 결정되는 공항이라는 것이므로, 무조건 path에 할당되어야 하는공항인 것이다.왜냐하면 더이상 경유할 공항이 이어지지 않는 공항이기 때문이다.
# len(route[top]) ==0 이라는 것은 출발 공항인 top가 더이상 갈 곳이 없는 상황이라는 것이므로, 도착지 공항으로 종결되는 상황이라는 것이다. 즉, path로 결정되어야 한다. 더이상 경유할 공항자체가 없으므로.

# top가 표현하는 공항이 딕셔너리인 routes에 속하지 않는다는 것은 routes 딕셔너리의 키에 top 공항이 표현하는 것과 같은 key가 존재하지 않는다는 것이다. 즉, 이경우의 top이 표현하는 공항은 출발공항이 아니라는 것이다.
# 그리고 만약 top가 표현하는 공항이 routes 딕셔너리의 키에 포함되어 routes[top] 동작이 가능할 경우 위와 같이 표현할 수 있는 위의 경우는 출발공항을 표현하는 top 공항에 대하여 도착하는 공항이 존재하지 않음을 표현하는 경우이다.
# 즉, top가 출발공항이지만 그에 대응되는 도착공항은 존재하지 않는 경우를 의미한다.


            path.append(stack.pop())

# 이어서 경유할 곳이 더이상 없는 상황이 가장 먼저 발생하는 공항일 수록 최종 도착지가 되어야 하는 우선순위가 높으므로, 위의 코드처럼 가장 먼저 path에 담기어야 한다.

        else:

            stack.append(routes[top][-1])

            routes[top] = routes[top][:-1]

# else 조건문에서는 top가 표현하는 공항이 출발공항이면서 그에 대응되는 도착공항도 존재하는 일반적인 경우를 표현하는데, 이 때엔 top에 대한 도착공항인 value의 끝 값은 알파벳 순서로 가장 앞선 공항이므로 이를 stack에 저장하고, top을 key로 하는 딕셔너리를 출력된 value를 제외한 상태로 맞춰준다.
# 그결과, top 출발 공항에 대응하는 가장 앞선 알파벳 순서의 도착공항이 stack에 top 바로 위에 쌓이게 되고,

    return path[::-1]






