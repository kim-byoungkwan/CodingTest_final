###.1 연결리스트

# 어떠한 데이터가 input()에 의해 입력될 때, node라는 데이터 저장공간이 형성되는데, node안에는 데이터를 저장할 수 있는 데이터 필드와 다음 노드가 어디인지 알려주는 링크라는 변수가 있다. 이 링크라는 변수의 생김새에 따라서 어떤 종류의 리스트에 노드가 포함되어 있는지 알 수 있다.

# 리스트의 첫번째 노드를 헤드라고 부르고 마지막 모드를 tail 이라고 부른다.

# 만약 노드당 다음 링크를 알려주는 링크가 하나밖에 존재하지 않는다면 single linked list 라고 부르고, 이 리스트는 오직 한방향으로만 흐르게 된다.그런데 만약, 노드에 다음 노드가 어디인지 알려주는 링크 뿐만 아니라 이전 노드가 어디인지 알려주는 링크 또한 저장한다면 리스트는 양방향으로 흐름이 형성될 수 있고, 이러한 리스트를 doubly linked list 라고 부른다. 또한 만약, 마지막 노드가 첫번째 노드를 가르키게 되면 링크의 노드는 끊임없이 흐름이 형성될 수 있는 구조를 갖게 되는데 이러한 리스트를 circular linked list 즉, 환형 연결 리스트라고 한다.

# doubly linked list는 single linked list와는 달리 tail에서 head방향으로 이동할 수도 있는 리스트인 것이다.

# 리스트엔 노드가 포함되고 노드엔 링크 변수가 포함되게 되는데 이 링크 변수는 하나당 4byte를 차지하게 된다. 즉, 하나의 리스트 안에 10개의 노드가 있다고 하면 약 40byte의 메모리가 링크변수에 의해 소모되게 되는 것이다. 만약 리스트가 doubly linked list 라면 10개의 노드에 의해 리스트는 80byte의 메모리를 소모하게 되는 것이다.

# 또한 만약 데이터 하나당 추가적으로 소모되는 메모리 양이 노드가 증가함에 따라서 커질 때엔 리스트 보다는 어레이를 자료구조로 사용하는 것이 효과적이다. 그러나, 만약 100개의 노드가 포함된 리스트에서 중간에 위치한 50번째 노드를 삭제하는 경우 리스트를 사용하면 리스트의 노드엔 다음 노드의 위치와 이전 노드의 위치가 포함된 링크변수가 있으므로, 단순하게 49번째 노드의 링크 변수의 값을 삭제된 50번째 노드가 아닌 51번째 노드의 링크로 표현해주기만 하면 원래 리스트의 노드의 순서에 변화없이 리스트를 똑같이 유지할 수 있게 되므로 매우 효율적이다. 그러나, 이경우 자료구조가 어레이인 경우 중간에 삭제 된 노드에 의해 모든 노드의 순서를 바꿔줘야하므로 매우 비효율적인 동작이 필요하게 되어 매우 비효율적이다. 따라서 이런 경우에 리스트를 자료구조로 사용하는 것이 더 효율적이다.

# 필요한 상황에 맞는 자료구조를 사용하여야 한다.

# 배열은 배열의 노드가 물리적으로 한곳에 모여있으므로, 배열의 크기를 한번 정하면 배열을 늘이거나 줄일 수 없게 된다.

# 연결리스트란 요소값이 순서를 지어 나열된 상태에서 앞의 요소에 뒤의 요소값을 가리키는 방식으로 나열된 리스트를 의미한다. 즉, 요소값이 하나씩 담겨있는 노드에는 요소값인 데이터 그 자체와 그 다음의 요소값을 가리키는 link 값 또한 포함되어 있다. 이때, 노드내에 존재하는 데이터는 다른 구조인 문자열 레코드, 또다른 연결리스트일 수 있다.

# 데이터와 link 값이 합쳐지면 하나의 노드가 생성된다.

# 리스트의 맨 앞 요소값을 Head 라고 표현한다. 그리고 리스트의 맨 끝 노드의 요소값을 Tail 이라고 표현한다.



##.1 자료구조의 정의

class Node:

    def __init__(self,item):

        self.data = item

        self.next = None


# 생성자의 인자로 주어진 item을 Node 클래스 자신의 데이터라는 객체에 저장하고, next 객체에는 아무것도 저장하지 않는 생성자를 의미한다. 즉, 하나의 노드를 포함하고, 그 하나의 노드의 데이터는 생성자의 인자로 받아들인 item이고 노드의 link는 아무것도 가리키고 있지 않은 연결리스트를 표현하는 생성자이다.


class LinkedList:

    def __init__(self):

        self.nodeCount = 0

        self.head = None

        self.tail = None

# LinkedList라는 클래스는 어떠한 인자를 받아들이지 않고 있고, 생성과 동시에 nodeCount 객체를 생성하여 0을 저장하고, head라는 객체를 생성하여 None를 저장하고, tail라는 객체를 생성하여 None를 저장하는 생성자이다. 즉, 이는 노드의 개수도 0 이고 head도 아무것도 가리키지 않고 있고, tail도 아무것도 가리키고 있지 않는 비어있는 연결리스트를 표현하는 생성자이다.

    def getAt(self,pos):

    # 여기서 getAt는 일반적인 함수라기보다 첫번째 인자가 self로 주어진 것을 보면 어떠한 클래스의 메소드   인것을 알 수 있다. 즉, 이 경우엔 앞서서 정의한 LinkedList 클래스의 메소드이다.

    # 여기서 입력되는 pos 인자는 내가 찾고자 하는 값의 연결리스트에서의 위치값을 의미한다. 즉, pos 번째   에 있는 노드를 찾고자 하는 것이다.

        if pos <= 0 or pos> self.nodeCount:

            return None

        # 그러므로, 위의 getAt 메소드는 우리가 찾고자 하는 위치인 pos 인자값이 0보다 작거나, 노드의        총 개수인 nodeCount 값보다 크다면 그 위치에 존재 하는 값은 없으므로 None를 출력하는 메소드         를 의미한다.

        i = 1

        curr = self.head

        # self.head는 생성자에 의해 LinkedList 클래스에 자동으로 형성되어 있는 변수이다.
        # 위 코드는 i를 1로하고 curr 변수에 self.head 를 할당하였으므로, 연결리스트의 첫번째 노드         를 표현하는 상태의 코드이다.

        while i < pos:

            curr = curr.next

            i += 1

        return curr












 













